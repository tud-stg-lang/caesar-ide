package org.caesarj.ui.model;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Stack;

import org.apache.log4j.Logger;
import org.aspectj.asm.ProgramElementNode;
import org.aspectj.asm.StructureModel;
import org.aspectj.asm.StructureNode;
import org.aspectj.bridge.ISourceLocation;
import org.aspectj.bridge.SourceLocation;
import org.caesarj.compiler.ast.phylum.JClassImport;
import org.caesarj.compiler.ast.phylum.JCompilationUnit;
import org.caesarj.compiler.ast.phylum.JPackageImport;
import org.caesarj.compiler.ast.phylum.JPackageName;
import org.caesarj.compiler.ast.phylum.JPhylum;
import org.caesarj.compiler.ast.phylum.declaration.CjAdviceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjClassDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjInterfaceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjPointcutDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JClassDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JConstructorDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JFieldDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JInterfaceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JMethodDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JTypeDeclaration;
import org.caesarj.compiler.ast.phylum.expression.JExpression;
import org.caesarj.compiler.ast.phylum.statement.JBlock;
import org.caesarj.compiler.ast.phylum.statement.JConstructorBlock;
import org.caesarj.compiler.ast.phylum.variable.JFormalParameter;
import org.caesarj.compiler.ast.visitor.BodyVisitor;
import org.caesarj.compiler.export.CModifier;
import org.caesarj.compiler.types.CReferenceType;
import org.caesarj.compiler.types.CType;
import org.caesarj.compiler.types.CTypeVariable;
import org.caesarj.util.TokenReference;
/**
 * Main Class for generating ASM for caesar source code.
 * 
 * the protocoll is:
 * preBuild -> build(+) -> preWeave -> postBuild
 * NOTE: build method is called each time a compilation unit is parsed
 * 
 * @author Ivica Aracic <ivica.aracic@bytelords.de>
 */
public class AsmBuilder extends BodyVisitor {

	private static final String REGISTRY_CLASS_NAME = "Registry";

	protected StructureModel structureModel = null;
	protected Stack asmStack = new Stack();
	protected Stack classStack = new Stack();

	static Logger logger = Logger.getLogger(AsmBuilder.class);
	/**
	 * initialize the model
	 */
	public static void preBuild(StructureModel structureModel) {
		String rootLabel = "<root>";
		structureModel.setRoot(
			new ProgramElementNode(rootLabel, ProgramElementNode.Kind.FILE_JAVA, new ArrayList()));

		structureModel.setFileMap(new HashMap());
	}

	/**
	 * resolve advice and method signatures before weaving
	 */
	public static void preWeave(StructureModel structureModel) {
		SignatureResolver adviceNameVisitor = new SignatureResolver();
		adviceNameVisitor.visit(structureModel.getRoot());
	}

	/**
	 * remove support methods and inner classes
	 */
	public static void postBuild(StructureModel structureModel) {
		NodeEliminator nodeEliminator = new NodeEliminator();
		nodeEliminator.visit(structureModel.getRoot());
		nodeEliminator.eliminateNodes();
	}

	/**
	 * insert a single compilation unit to model
	 */
	public static void build(JCompilationUnit unit, StructureModel structureModel) {
		new AsmBuilder().internalBuild(unit, structureModel);
	}

	/**
	 * Support methods generated by caesar compiler should not be visible
	 * in ASM. 
	 * 
	 * @return true if this node should be removed in final ASM
	 */
	public static boolean isToRemove(StructureNode node) {

		if (node instanceof AspectRegistryNode) {
			return true;
		}

		if (node instanceof CaesarProgramElementNode) {
			String nodeName = node.getName();
			return nodeName.equals("_getBinding")
				|| nodeName.equals("_getProviding")
				|| nodeName.equals("_getProvidingReference")
				|| nodeName.equals("_getWrappee");
		}

		return false;
	}

	private void internalBuild(JCompilationUnit unit, StructureModel structureModel) {
		if (unit == null)
			return;

		setStructureModel(structureModel);
		asmStack.push(structureModel.getRoot());

		unit.accept(this);

		asmStack.pop();
		setStructureModel(null);
	}

	/**
	 * CompilationUnit visit method
	 */
	public void visitCompilationUnit(
		JCompilationUnit self,
		JPackageName packageName,
		JPackageImport[] importedPackages,
		JClassImport[] importedClasses,
		JTypeDeclaration[] typeDeclarations) {

		TokenReference ref = self.getTokenReference();
		File file = new File(new String(ref.getFile()));

		//TODO Es gibt keine Felder für Error oder Warnings.???
		//TODO Sourcefile unterscheidung einbauen
		//JavaSourceFileNode
		//AspectSourceFileNode
		JavaSourceFileNode cuNode =
			new JavaSourceFileNode(
				new String(file.getName()),
				CaesarProgramElementNode.Kind.FILE_JAVA,
				makeLocation(ref),
				0,
				"",
				new ArrayList(),
				importedPackages,
				importedClasses);

		if (packageName != null) {

			String pkgName = packageName.getName();

			pkgName = pkgName.replaceAll("/", ".");

			boolean found = false;
			CaesarProgramElementNode pkgNode = null;

			for (Iterator it = getStructureModel().getRoot().getChildren().iterator();
				it.hasNext();
				) {
				CaesarProgramElementNode currNode = (CaesarProgramElementNode) it.next();
				if (currNode.getName().equals(pkgName))
					pkgNode = currNode;
			}

			if (pkgNode == null) {
				pkgNode =
					new PackageNode(
						pkgName,
						CaesarProgramElementNode.Kind.PACKAGE,
						new ArrayList());
				getStructureModel().getRoot().addChild(pkgNode);
			}

			// if the node already exists remove before adding
			CaesarProgramElementNode duplicate = null;

			for (Iterator itt = pkgNode.getChildren().iterator(); itt.hasNext();) {
				CaesarProgramElementNode child = (CaesarProgramElementNode) itt.next();
				if (child.getSourceLocation().getSourceFile().equals(file)) {
					pkgNode.removeChild(child);
				}
			}
			/*if (duplicate != null) {pkgNode.removeChild(duplicate);}*/
			pkgNode.addChild(cuNode);
		} else {
			// if the node already exists remove before adding
			CaesarProgramElementNode duplicate = null;

			for (Iterator itt = getStructureModel().getRoot().getChildren().iterator();
				itt.hasNext();
				) {
				CaesarProgramElementNode child = (CaesarProgramElementNode) itt.next();
				if (child.getSourceLocation().getSourceFile().equals(file)) {
					getStructureModel().getRoot().removeChild(child);
				}
			}
			/*if (duplicate != null) {getStructureModel().getRoot().removeChild(duplicate);}*/
			getCurrentStructureNode().addChild(cuNode);
		}

		try {
			//StructureModelManager.INSTANCE.getStructureModel().getFileMap().put(
			getStructureModel().addToFileMap(file.getCanonicalPath(), cuNode);
		} catch (IOException ioe) {
			logger.error("WAS weiß ich den watt hier pasiere töt", ioe);
		}

		asmStack.push(cuNode);

		super.visitCompilationUnit(
			self,
			packageName,
			importedPackages,
			importedClasses,
			typeDeclarations);

		asmStack.pop();
	}
	
	public void visitCciInterfaceDeclaration(CjInterfaceDeclaration arg0,
			int arg1, String arg2, CReferenceType[] arg3, JPhylum[] arg4,
			JMethodDeclaration[] arg5) {
		visitInterfaceDeclaration(arg0, arg1, arg2, arg3, arg4, arg5);
	}

	/**
	 * Interface visit method
	 */
	public void visitInterfaceDeclaration(
		JInterfaceDeclaration self,
		int modifiers,
		String ident,
		CReferenceType[] interfaces,
		JPhylum[] body,
		JMethodDeclaration[] methods) {
		InterfaceNode peNode =
			new InterfaceNode(
				ident,
				CaesarProgramElementNode.Kind.INTERFACE,
				makeLocation(self.getTokenReference()),
				modifiers,
				"",
				new ArrayList());

		getCurrentStructureNode().addChild(peNode);
		asmStack.push(peNode);
		classStack.push(self);

		//FIELDS
		JFieldDeclaration types[] = self.getFields();
		for (int i = 0; i < types.length; i++) {
			types[i].accept(this);
		}
		
		//TODO In methodenvisitor gibt es beim Aufruf einen Nullpointer!!!
		//METHODEN
		for (int i = 0; i < methods.length; i++) {
			methods[i].accept(this);
		}

		JTypeDeclaration inners[] = self.getInners();
		for (int i = 0; i < inners.length; i++) {
			inners[i].accept(this);
		}

		asmStack.pop();
		classStack.pop();
	}

	/**
	 * crosscutting und normal classes
	 */
	public void visitClassDeclaration(
		JClassDeclaration self,
		int modifiers,
		String ident,
		CTypeVariable[] typeVariables,
		String superClass,
		CReferenceType[] interfaces,
		JPhylum[] body,
		JMethodDeclaration[] methods,
		JTypeDeclaration[] decls) {

		classStack.push(self);

		CaesarProgramElementNode peNode;

		if (CModifier.contains(modifiers, CModifier.ACC_CROSSCUTTING)) {
			peNode =
				new AspectNode(
					ident,
					CaesarProgramElementNode.Kind.ASPECT,
					makeLocation(self.getTokenReference()),
					modifiers,
					"",
					new ArrayList());
		} else {
			peNode =
				new ClassNode(
					ident,
					CaesarProgramElementNode.Kind.CLASS,
					makeLocation(self.getTokenReference()),
					modifiers,
					"",
					new ArrayList());
		}

		getCurrentStructureNode().addChild(peNode);
		asmStack.push(peNode);

		// super method ruft nicht die field visitors auf        
		/*
		super.visitClassDeclaration(
			self, modifiers, ident, typeVariables, superClass,
			interfaces, body, methods, decls
		);
		*/

		for (int i = 0; i < decls.length; i++) {
			decls[i].accept(this);
		}

		for (int i = 0; i < methods.length; i++) {
			methods[i].accept(this);
		}

		for (int i = 0; i < body.length; i++) {
			body[i].accept(this);
		}

		// get advices and pointcuts visit
		if (self instanceof CjClassDeclaration) {
			CjClassDeclaration clazz = (CjClassDeclaration) self;

			CjAdviceDeclaration[] advices = clazz.getAdvices();
			for (int i = 0; i < advices.length; i++) {
				advices[i].accept(this);
			}

			CjPointcutDeclaration[] pointcuts = clazz.getPointcuts();
			for (int i = 0; i < pointcuts.length; i++) {
				pointcuts[i].accept(this);
			}
		}

		asmStack.pop();
		classStack.pop();
	}

	/**
	 * ConstructorDeclaration
	 * 
	 */
	public void visitConstructorDeclaration(
		JConstructorDeclaration self,
		int modifiers,
		String ident,
		JFormalParameter[] parameters,
		CReferenceType[] exceptions,
		JConstructorBlock body) {
		ConstructorDeclarationNode peNode =
			new ConstructorDeclarationNode(
				self,
				((JClassDeclaration) classStack.peek()),
				ident,
				CaesarProgramElementNode.Kind.CONSTRUCTOR,
				makeLocation(self.getTokenReference()),
				modifiers,
				"",
				new ArrayList());

		getCurrentStructureNode().addChild(peNode);

		asmStack.push(peNode);

		super.visitConstructorDeclaration(self, modifiers, ident, parameters, exceptions, body);

		asmStack.pop();
	}

	/**
	 * MethodDeclaration
	 */
	public void visitMethodDeclaration(
		JMethodDeclaration self,
		int modifiers,
		CTypeVariable[] typeVariables,
		CType returnType,
		String ident,
		JFormalParameter[] parameters,
		CReferenceType[] exceptions,
		JBlock body) {
		CaesarProgramElementNode peNode = null;

		if (self instanceof CjAdviceDeclaration) {
			CjAdviceDeclaration advice = (CjAdviceDeclaration) self;

			peNode =
				new AdviceDeclarationNode(
					advice,
					((JTypeDeclaration) classStack.peek()).getCClass().getQualifiedName(),
					advice.getKind().wrappee().getName(),
					CaesarProgramElementNode.Kind.ADVICE,
					makeLocation(self.getTokenReference()),
					modifiers,
					"",
					new ArrayList());

			if (CModifier
				.contains(
					((JTypeDeclaration) classStack.peek()).getModifiers(),
					CModifier.ACC_DEPLOYED)) {
				getCurrentStructureNode().addChild(peNode);
			} else {
				CaesarProgramElementNode registryNode =
					findChildByName(getCurrentStructureNode().getChildren(), REGISTRY_CLASS_NAME);

				if (registryNode == null) {
					registryNode =
						new AspectRegistryNode(
							"Registry",
							CaesarProgramElementNode.Kind.CLASS,
							makeLocation(self.getTokenReference()),
							modifiers,
							"",
							new ArrayList());

					getCurrentStructureNode().addChild(registryNode);
				}

				registryNode.addChild(peNode);
			}
		} else if (self instanceof CjPointcutDeclaration) {
			CjPointcutDeclaration pointcut = (CjPointcutDeclaration) self;

			peNode =
				new PointcutNode(
					pointcut,
					((JClassDeclaration) classStack.peek()),
					ident,
					CaesarProgramElementNode.Kind.POINTCUT,
					makeLocation(self.getTokenReference()),
					modifiers,
					"",
					new ArrayList());

			getCurrentStructureNode().addChild(peNode);
		} else {
			peNode =
				new MethodDeclarationNode(
					self,
					((JTypeDeclaration) classStack.peek()),
					ident,
					CaesarProgramElementNode.Kind.METHOD,
					makeLocation(self.getTokenReference()),
					modifiers,
					"",
					new ArrayList());

			if (ident.equals("main")) {
				peNode.setRunnable(true);
			}

			getCurrentStructureNode().addChild(peNode);
		}

	}

	/**
	 * FIELD
	 */
	public void visitFieldDeclaration(
		JFieldDeclaration self,
		int modifiers,
		CType type,
		String ident,
		JExpression expr) {
		FieldNode peNode =
			new FieldNode(
				ident,
				CaesarProgramElementNode.Kind.FIELD,
				makeLocation(self.getTokenReference()),
				type,
				modifiers,
				"",
				new ArrayList());

		getCurrentStructureNode().addChild(peNode);
	}

	
	private ISourceLocation makeLocation(TokenReference ref) {
		String fileName = new String(ref.getFile());

		return new SourceLocation(new File(fileName), ref.getLine());
	}

	private StructureNode getCurrentStructureNode() {
		return (StructureNode) asmStack.peek();
	}

	private void setStructureModel(StructureModel structureModel) {
		this.structureModel = structureModel;
	}

	private StructureModel getStructureModel() {
		return structureModel;
	}

	/*
	 * HELPER METHODS
	 */

	private CaesarProgramElementNode findChildByName(Collection childrenList, String name) {
		for (Iterator it = childrenList.iterator(); it.hasNext();) {
			CaesarProgramElementNode node = (CaesarProgramElementNode) it.next();

			if (node.getName().equals(name))
				return node;
		}

		return null;
	}

}
