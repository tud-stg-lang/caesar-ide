package org.caesarj.ui.model;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Stack;

import org.apache.log4j.Logger;
import org.aspectj.asm.ProgramElementNode;
import org.aspectj.asm.StructureModel;
import org.aspectj.asm.StructureNode;
import org.aspectj.bridge.ISourceLocation;
import org.aspectj.bridge.SourceLocation;
import org.caesarj.classfile.ClassfileConstants2;
import org.caesarj.compiler.ast.phylum.JCompilationUnit;
import org.caesarj.compiler.ast.phylum.declaration.CjAdviceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjAdviceMethodDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjDeploymentSupportClassDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjInterfaceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjMixinInterfaceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjPointcutDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.CjVirtualClassDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JClassDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JConstructorDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JFieldDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JInterfaceDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JMethodDeclaration;
import org.caesarj.compiler.ast.phylum.declaration.JTypeDeclaration;
import org.caesarj.compiler.ast.phylum.variable.JVariableDefinition;
import org.caesarj.compiler.ast.visitor.VisitorSupport;
import org.caesarj.compiler.export.CModifier;
import org.caesarj.util.TokenReference;

/**
 * Main Class for generating ASM for caesar source code.
 * 
 * the protocoll is: preBuild -> build(+) -> preWeave -> postBuild NOTE: build
 * method is called each time a compilation unit is parsed
 * 
 * @author Ivica Aracic
 */
public class AsmBuilder {

	private static final String REGISTRY_CLASS_NAME = "Registry"; //$NON-NLS-1$

	protected StructureModel structureModel = null;

	protected Stack asmStack = new Stack();

	protected Stack classStack = new Stack();

	static Logger logger = Logger.getLogger(AsmBuilder.class);

	/**
	 * initialize the model
	 */
	public static void preBuild(StructureModel structureModel) {
		String rootLabel = "<root>"; //$NON-NLS-1$
		structureModel.setRoot(new ProgramElementNode(rootLabel,
				ProgramElementNode.Kind.FILE_JAVA, new ArrayList()));

		structureModel.setFileMap(new HashMap());
	}

	/**
	 * resolve advice and method signatures before weaving
	 */
	public static void preWeave(StructureModel structureModel) {

	}

	/**
	 * remove support methods and inner classes
	 */
	public static void postBuild(StructureModel structureModel) {
		NodeEliminator nodeEliminator = new NodeEliminator();
		nodeEliminator.visit(structureModel.getRoot());
		nodeEliminator.eliminateNodes();
	}

	/**
	 * insert a single compilation unit to model
	 */
	public static void build(JCompilationUnit unit,
			StructureModel structureModel) {
		new AsmBuilder().internalBuild(unit, structureModel);
	}

	/**
	 * Support methods generated by caesar compiler should not be visible in
	 * ASM.
	 * 
	 * @return true if this node should be removed in final ASM
	 */
	public static boolean isToRemove(StructureNode node) {

		if (node instanceof AspectRegistryNode) {
			return true;
		}
		//
		//		if (node instanceof CaesarProgramElementNode) {
		//			String nodeName = node.getName();
		//			return nodeName.equals("_getBinding") //$NON-NLS-1$
		//				|| nodeName.equals("_getProviding") //$NON-NLS-1$
		//				|| nodeName.equals("_getProvidingReference") //$NON-NLS-1$
		//				|| nodeName.equals("_getWrappee"); //$NON-NLS-1$
		//		}

		return false;
	}

	private void internalBuild(JCompilationUnit unit,
			StructureModel structureModelArg) {
		if (unit == null)
			return;

		setStructureModel(structureModelArg);
		this.asmStack.push(structureModelArg.getRoot());

		VisitorSupport visitor = new VisitorSupport(this);
		unit.accept(visitor);

		this.asmStack.pop();
		setStructureModel(null);
	}

	/**
	 * CompilationUnit visit method
	 */
	public boolean visit(JCompilationUnit self) {
		TokenReference ref = self.getTokenReference();
		File file = new File(new String(ref.getFile()));

		JavaSourceFileNode cuNode = new JavaSourceFileNode(new String(file
				.getName()), CaesarProgramElementNode.Kind.FILE_JAVA,
				makeLocation(ref), 0, "", //$NON-NLS-1$
				new ArrayList(), self.getImportedPackages(), self
						.getImportedClasses());

		if (self.getPackageName() != null) {

			String pkgName = self.getPackageName().getName();

			pkgName = pkgName.replaceAll("/", "."); //$NON-NLS-1$ //$NON-NLS-2$

			CaesarProgramElementNode pkgNode = null;

			for (Iterator it = getStructureModel().getRoot().getChildren()
					.iterator(); it.hasNext();) {
				CaesarProgramElementNode currNode = (CaesarProgramElementNode) it
						.next();
				if (currNode.getName().equals(pkgName))
					pkgNode = currNode;
			}

			if (pkgNode == null) {
				pkgNode = new PackageNode(pkgName,
						CaesarProgramElementNode.Kind.PACKAGE, new ArrayList());
				getStructureModel().getRoot().addChild(pkgNode);
			}

			for (Iterator itt = pkgNode.getChildren().iterator(); itt.hasNext();) {
				CaesarProgramElementNode child = (CaesarProgramElementNode) itt
						.next();
				if (child.getSourceLocation().getSourceFile().equals(file)) {
					pkgNode.removeChild(child);
				}
			}
			pkgNode.addChild(cuNode);
		} else {
			// if the node already exists remove before adding

			for (Iterator itt = getStructureModel().getRoot().getChildren()
					.iterator(); itt.hasNext();) {
				CaesarProgramElementNode child = (CaesarProgramElementNode) itt
						.next();
				if (child.getSourceLocation().getSourceFile().equals(file)) {
					getStructureModel().getRoot().removeChild(child);
				}
			}
			getCurrentStructureNode().addChild(cuNode);
		}

		try {
			getStructureModel().addToFileMap(file.getCanonicalPath(), cuNode);
		} catch (IOException ioe) {
			logger.error("WAS weiß ich den watt hier pasiere töt", ioe); //$NON-NLS-1$
		}

		this.asmStack.push(cuNode);

		return true;
	}

	public void endVisit(JCompilationUnit self) {
		this.asmStack.pop();
	}

	/*
	 * INTERFACES
	 */

	/** handle all interface types equivalent */
	public boolean visit(JInterfaceDeclaration self) {
		InterfaceNode peNode = new InterfaceNode(self.getIdent(),
				CaesarProgramElementNode.Kind.INTERFACE, makeLocation(self
						.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
				new ArrayList());

		getCurrentStructureNode().addChild(peNode);
		this.asmStack.push(peNode);
		this.classStack.push(self);

		return true;
	}

	public void endVisit(JInterfaceDeclaration self) {
		this.asmStack.pop();
		this.classStack.pop();
	}

	// dont't visit mixin interface
	public boolean visit(CjMixinInterfaceDeclaration self) {
		return false;
	}

	// dont't visit support ifcs
	public boolean visit(CjInterfaceDeclaration self) {
		return false;
	}

	// don't visit registry class
	public boolean visit(CjDeploymentSupportClassDeclaration self) {
		return false;
	}

	/*
	 * CLASS DECLARATIONS
	 */

	/**
	 * crosscutting und normal classes
	 */
	public boolean visit(JClassDeclaration self) {
		this.classStack.push(self);

		CaesarProgramElementNode peNode;

		if (CModifier.contains(self.getModifiers(),
				ClassfileConstants2.ACC_CROSSCUTTING)) {
			peNode = new AspectNode(self.getIdent(),
					CaesarProgramElementNode.Kind.ASPECT, makeLocation(self
							.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
					new ArrayList(), self.getCClass());
		} else if (self instanceof CjVirtualClassDeclaration) {

			if (self.getCClass().isImplicit()) {
				this.asmStack.push(null);
				return false;
			}

			peNode = new CClassNode(self.getIdent(),
					CaesarProgramElementNode.Kind.CLASS, makeLocation(self
							.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
					new ArrayList(), self.getCClass());
		} else {
			peNode = new ClassNode(self.getIdent(),
					CaesarProgramElementNode.Kind.CLASS, makeLocation(self
							.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
					new ArrayList());
		}

		getCurrentStructureNode().addChild(peNode);
		this.asmStack.push(peNode);

		return true;
	}

	public void endVisit(JClassDeclaration self) {
		this.asmStack.pop();
		this.classStack.pop();
	}

	/**
	 * ConstructorDeclaration
	 *  
	 */
	public boolean visit(JConstructorDeclaration self) {
		ConstructorDeclarationNode peNode = new ConstructorDeclarationNode(
				self, ((JClassDeclaration) this.classStack.peek()), self
						.getIdent(), CaesarProgramElementNode.Kind.CONSTRUCTOR,
				makeLocation(self.getTokenReference()), self.getModifiers(),
				"", //$NON-NLS-1$
				new ArrayList());

		peNode.setBytecodeName(self.getIdent());
		peNode.setBytecodeSignature(self.getMethod().getSignature());

		getCurrentStructureNode().addChild(peNode);
		return false;
	}

	/**
	 * MethodDeclaration
	 */
	public boolean visit(JMethodDeclaration self) {

		if (self.getIdent().startsWith("$"))
			return false;

		CaesarProgramElementNode peNode = new MethodDeclarationNode(self,
				((JTypeDeclaration) this.classStack.peek()), self.getIdent(),
				CaesarProgramElementNode.Kind.METHOD, makeLocation(self
						.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
				new ArrayList());

		peNode.setBytecodeName(self.getIdent());
		peNode.setBytecodeSignature(self.getMethod().getSignature());

		if (self.getIdent().equals("main")) { //$NON-NLS-1$
			peNode.setRunnable(true);
		}

		getCurrentStructureNode().addChild(peNode);

		return false;
	}

	public boolean visit(CjPointcutDeclaration pointcut) {
		CaesarProgramElementNode peNode = new PointcutNode(pointcut,
				((JClassDeclaration) this.classStack.peek()), pointcut
						.getIdent(), CaesarProgramElementNode.Kind.POINTCUT,
				makeLocation(pointcut.getTokenReference()), pointcut
						.getModifiers(), "", //$NON-NLS-1$
				new ArrayList());
		getCurrentStructureNode().addChild(peNode);
		return false;
	}

	public boolean visit(CjAdviceMethodDeclaration self) {
		CaesarProgramElementNode peNode = new AdviceDeclarationNode(
				((JTypeDeclaration) this.classStack.peek()).getCClass()
						.getQualifiedName(), self.getAdvice().getKind()
						.wrappee().getName(),
				CaesarProgramElementNode.Kind.ADVICE, makeLocation(self
						.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
				new ArrayList());

		peNode.setBytecodeName(self.getIdent());
		peNode.setBytecodeSignature(self.getMethod().getSignature());

		{
			CaesarProgramElementNode registryNode = findChildByName(
					getCurrentStructureNode().getChildren(),
					REGISTRY_CLASS_NAME);
			if (registryNode == null) {
				registryNode = new AspectRegistryNode(REGISTRY_CLASS_NAME, //$NON-NLS-1$
						CaesarProgramElementNode.Kind.CLASS, makeLocation(self
								.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
						new ArrayList());
				getCurrentStructureNode().addChild(registryNode);
			}
			registryNode.addChild(peNode);
		}
		return false;
	}

	public boolean visit(CjAdviceDeclaration self) {
		CaesarProgramElementNode peNode = new AdviceDeclarationNode(
				((JTypeDeclaration) this.classStack.peek()).getCClass()
						.getQualifiedName(),
				self.getKind().wrappee().getName(),
				CaesarProgramElementNode.Kind.ADVICE, makeLocation(self
						.getTokenReference()), self.getModifiers(), "", //$NON-NLS-1$
				new ArrayList());

		peNode.setBytecodeName(self.getIdent());
		peNode.setBytecodeSignature(self.getMethod().getSignature());

		getCurrentStructureNode().addChild(peNode);

		return false;
	}

	/**
	 * FIELD
	 */
	public boolean visit(JFieldDeclaration self) {

		if (self.getVariable().getIdent().startsWith("$"))
			return false;

		JVariableDefinition var = self.getVariable();
		FieldNode peNode = new FieldNode(var.getIdent(),
				CaesarProgramElementNode.Kind.FIELD, makeLocation(self
						.getTokenReference()), var.getType(), var
						.getModifiers(), "", //$NON-NLS-1$
				new ArrayList());

		getCurrentStructureNode().addChild(peNode);

		return false;
	}

	private ISourceLocation makeLocation(TokenReference ref) {
		String fileName = new String(ref.getFile());

		return new SourceLocation(new File(fileName), ref.getLine());
	}

	private StructureNode getCurrentStructureNode() {
		return (StructureNode) this.asmStack.peek();
	}

	private void setStructureModel(StructureModel structureModelArg) {
		this.structureModel = structureModelArg;
	}

	private StructureModel getStructureModel() {
		return this.structureModel;
	}

	/*
	 * HELPER METHODS
	 */

	private CaesarProgramElementNode findChildByName(Collection childrenList,
			String name) {
		for (Iterator it = childrenList.iterator(); it.hasNext();) {
			CaesarProgramElementNode node = (CaesarProgramElementNode) it
					.next();

			if (node.getName().equals(name))
				return node;
		}

		return null;
	}

}